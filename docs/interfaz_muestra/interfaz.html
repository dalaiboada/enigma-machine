<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Simulación Enigma (HTML/JS)</title>
  <style>
    :root{--bg:#0f1724;--panel:#0b1220;--accent:#ffd166;--muted:#94a3b8;--card:#0b1220}
    html,body{height:100%;margin:0;font-family:Inter,Segoe UI,Arial;background:linear-gradient(180deg,#071028 0%, #071b2a 100%);color:#e6eef6}
    .app{max-width:1100px;margin:24px auto;padding:20px}
    h1{margin:0 0 8px;font-size:20px}
    .layout{display:grid;grid-template-columns:360px 1fr;gap:18px}
    .card{background:rgba(255,255,255,0.02);border-radius:12px;padding:14px;box-shadow:0 8px 20px rgba(2,6,23,0.6)}
    .small{font-size:13px;color:var(--muted)}

    .keyboard{display:grid;grid-template-columns:repeat(13,1fr);gap:6px;margin-top:12px}
    .key{background:#071328;border-radius:8px;padding:10px;text-align:center;cursor:pointer;user-select:none;border:1px solid rgba(255,255,255,0.03)}
    .key:active{transform:translateY(1px)}

    .rotor-row{display:flex;gap:8px;align-items:center}
    .rotor{flex:1;background:linear-gradient(180deg,#081226,#0b1830);border-radius:10px;padding:10px;text-align:center}
    .dial{display:inline-block;padding:8px 10px;border-radius:6px;background:rgba(255,255,255,0.03);font-weight:700}
    .label{font-size:12px;color:var(--muted)}

    .panel{display:flex;gap:12px;margin-top:12px}
    .plugboard{display:flex;flex-wrap:wrap;gap:8px}
    .pair{background:#081727;padding:6px;border-radius:8px;border:1px dashed rgba(255,255,255,0.02)}

    .lights{display:flex;flex-wrap:wrap;gap:6px;padding:8px;background:rgba(0,0,0,0.12);border-radius:10px}
    .lamp{width:36px;height:36px;border-radius:50%;display:flex;align-items:center;justify-content:center;background:#072235;color:#7f9fb9;font-weight:700}
    .lamp.on{background:var(--accent);color:#071226}

    .path{margin-top:12px}
    .path .step{font-size:13px;color:var(--muted);}

    .controls{display:flex;gap:8px;align-items:center}
    select,input[type="text"]{background:transparent;border:1px solid rgba(255,255,255,0.04);color:inherit;padding:6px;border-radius:6px}
    .btn{padding:8px 12px;border-radius:8px;background:#0b2a3f;border:1px solid rgba(255,255,255,0.03);cursor:pointer}

    footer{margin-top:14px;font-size:13px;color:var(--muted)}

    /* path visualization */
    .wire{display:flex;gap:6px;flex-wrap:wrap}
    .chip{padding:4px 6px;border-radius:6px;background:rgba(255,255,255,0.02);border:1px solid rgba(255,255,255,0.02)}
    .highlight{background:linear-gradient(90deg,rgba(255,209,102,0.2),rgba(255,209,102,0.05));border-color:rgba(255,209,102,0.3)}

    .config{display:grid;grid-template-columns:1fr 1fr;gap:8px}
  </style>
</head>
<body>
  <div class="app">
    <h1>Simulación Enigma — HTML/JS</h1>
    <div class="small">Pulsa una tecla en el teclado o haz clic en una tecla de la UI. Observa la trayectoria de la señal, las lámparas y el giro de los rotores.</div>

    <div class="layout">
      <div class="card">
        <div class="label">Rotores & posiciones</div>
        <div style="margin-top:8px" class="rotor-row">
          <div class="rotor" id="rotor-left">
            <div class="label">Izquierdo</div>
            <div style="margin-top:8px"><select id="rotorLeftSelect"></select></div>
            <div style="margin-top:8px"><span class="dial" id="leftPos">A</span></div>
          </div>
          <div class="rotor" id="rotor-mid">
            <div class="label">Medio</div>
            <div style="margin-top:8px"><select id="rotorMidSelect"></select></div>
            <div style="margin-top:8px"><span class="dial" id="midPos">A</span></div>
          </div>
          <div class="rotor" id="rotor-right">
            <div class="label">Derecho</div>
            <div style="margin-top:8px"><select id="rotorRightSelect"></select></div>
            <div style="margin-top:8px"><span class="dial" id="rightPos">A</span></div>
          </div>
        </div>

        <div style="margin-top:12px" class="label">Reflector</div>
        <div style="margin-top:8px"><select id="reflectorSelect"></select></div>

        <div style="margin-top:12px" class="label">Panel de clavijas (Plugboard)</div>
        <div style="margin-top:8px" class="plugboard" id="plugPairs"></div>
        <div style="margin-top:8px" class="controls">
          <input id="addPair" placeholder="Ej: A G" />
          <button class="btn" id="btnAdd">Agregar</button>
          <button class="btn" id="btnClear">Borrar pares</button>
        </div>

        <div style="margin-top:12px" class="label">Lámparas</div>
        <div class="lights" id="lamps"></div>

        <div style="margin-top:12px" class="label">Trayectoria (última tecla)</div>
        <div class="path" id="path"></div>

        <div style="margin-top:12px" class="config">
          <div>
            <div class="small">Notch (muestra posiciones que provocan paso del rotor de la izquierda)</div>
            <div id="notches" class="small" style="margin-top:6px"></div>
          </div>
          <div>
            <div class="small">Stepping: implementado con doble-stepping simplificado</div>
            <div class="small" style="margin-top:6px">Rotar -> rotor derecho siempre. Si rotor derecho al avanzar llega a su notch, hace girar al rotor medio. Si rotor medio está en notch, rotará también el rotor izquierdo (double-step).</div>
          </div>
        </div>

      </div>

      <div class="card">
        <div class="label">Teclado</div>
        <div class="keyboard" id="keyboard"></div>

        <div style="margin-top:12px" class="label">Salida: presión tecla</div>
        <div style="margin-top:6px" class="wire" id="outputWire"></div>

        <div style="margin-top:12px" class="label">Controles</div>
        <div style="margin-top:6px" class="controls">
          <button class="btn" id="btnReset">Reset posiciones (AAA)</button>
          <button class="btn" id="randomize">Aleatorizar posiciones</button>
        </div>

        <footer>
          Hecho para explicar la lógica de la Enigma — incluye: plugboard, 3 rotores, reflector, y stepping.
        </footer>
      </div>
    </div>
  </div>

<script>
// --- Datos históricos (rótulos reales): rotores I, II, III y Reflector B (ejemplos) ---
const ALPH = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
function idx(c){return ALPH.indexOf(c);} 
function chr(i){return ALPH[(i+26)%26];}

const ROTORS = {
  'I':  {wiring: 'EKMFLGDQVZNTOWYHXUSPAIBRCJ', notch: 'Q'},
  'II': {wiring: 'AJDKSIRUXBLHWTMCQGZNPYFVOE', notch: 'E'},
  'III':{wiring: 'BDFHJLCPRTXVZNYEIWGAKMUSQO', notch: 'V'},
  'IV': {wiring: 'ESOVPZJAYQUIRHXLNFTGKDCMWB', notch: 'J'},
  'V':  {wiring: 'VZBRGITYUPSDNHLXAWMJQOFECK', notch: 'Z'}
};

const REFLECTORS = {
  'B': 'YRUHQSLDPXNGOKMIEBFZCWVJAT',
  'C': 'FVPJIAOYEDRZXWGCTKUQSBNMHL'
};

// Estado de la máquina
let state = {
  left: {type:'I', pos:0},
  mid:  {type:'II', pos:0},
  right:{type:'III', pos:0},
  reflector: 'B',
  plugboard: {},
};

// Construcción de mapeos rápidos
function wiringMap(w){return w.split('').map(c=>idx(c));}

// init selects
const leftSelect = document.getElementById('rotorLeftSelect');
const midSelect = document.getElementById('rotorMidSelect');
const rightSelect = document.getElementById('rotorRightSelect');
const reflectorSelect = document.getElementById('reflectorSelect');

Object.keys(ROTORS).forEach(r=>{[leftSelect,midSelect,rightSelect].forEach(s=>{let o=document.createElement('option');o.value=r;o.textContent=r; s.appendChild(o)})});
Object.keys(REFLECTORS).forEach(r=>{let o=document.createElement('option');o.value=r;o.textContent=r; reflectorSelect.appendChild(o)});
leftSelect.value = state.left.type; midSelect.value=state.mid.type; rightSelect.value=state.right.type; reflectorSelect.value=state.reflector;

// UI elements
const leftPos = document.getElementById('leftPos');
const midPos  = document.getElementById('midPos');
const rightPos= document.getElementById('rightPos');
const plugsDiv = document.getElementById('plugPairs');
const lampsDiv = document.getElementById('lamps');
const keyboardDiv = document.getElementById('keyboard');
const pathDiv = document.getElementById('path');
const notchDiv = document.getElementById('notches');
const outputWire = document.getElementById('outputWire');

// Renders
function renderPositions(){ leftPos.textContent = chr(state.left.pos); midPos.textContent = chr(state.mid.pos); rightPos.textContent = chr(state.right.pos); }
function renderNotches(){
  notchDiv.innerHTML = `Izq: ${ROTORS[state.left.type].notch}, Medio: ${ROTORS[state.mid.type].notch}, Der: ${ROTORS[state.right.type].notch}`;
}

function renderPlugs(){ plugsDiv.innerHTML='';
  const pairs = Object.entries(state.plugboard);
  const shown = new Set();
  pairs.forEach(([k,v])=>{
    if(shown.has(k) || shown.has(v)) return; shown.add(k); shown.add(v);
    const el = document.createElement('div'); el.className='pair'; el.textContent = `${k} ↔ ${v}`;
    const btn = document.createElement('button'); btn.textContent='x'; btn.style.marginLeft='8px'; btn.onclick=()=>{delete state.plugboard[k]; delete state.plugboard[v]; renderPlugs(); renderLamps();}; el.appendChild(btn); plugsDiv.appendChild(el);
  });
}

function renderLamps(){ lampsDiv.innerHTML=''; for(let c of ALPH){const l=document.createElement('div'); l.className='lamp'; l.id='lamp_'+c; l.textContent=c; lampsDiv.appendChild(l);} }

function renderKeyboard(){ keyboardDiv.innerHTML=''; for(let c of ALPH){ const k=document.createElement('div'); k.className='key'; k.textContent=c; k.onclick=()=>pressKey(c); keyboardDiv.appendChild(k);} }

// --- Enigma core logic ---
function plugSwap(c){ return state.plugboard[c] || c; }

function rotorForward(letterIdx, rotor){
  // rotor: {type,pos}
  const wiring = wiringMap(ROTORS[rotor.type].wiring);
  // applying rotation: (input + pos) -> wiring -> -pos
  const steppedIn = (letterIdx + rotor.pos) % 26;
  const wired = wiring[steppedIn];
  const out = (wired - rotor.pos + 26) % 26;
  return out;
}

function rotorBackward(letterIdx, rotor){
  // inverse mapping
  const wiring = wiringMap(ROTORS[rotor.type].wiring);
  const steppedIn = (letterIdx + rotor.pos) % 26;
  // find index i such that wiring[i] == steppedIn
  const i = wiring.indexOf(steppedIn);
  const out = (i - rotor.pos + 26) % 26;
  return out;
}

function reflect(letterIdx){
  const ref = REFLECTORS[state.reflector];
  return idx(ref[letterIdx]);
}

function stepRotors(){
  // implement stepping with double-step behavior
  const rightNotchPos = idx(ROTORS[state.right.type].notch);
  const midNotchPos   = idx(ROTORS[state.mid.type].notch);

  // Determine if middle will step due to right being at notch AFTER step?
  // Historical simplified: if middle is at notch, it will step (double-step effect)
  const willStepMid = (state.right.pos === rightNotchPos) || (state.mid.pos === midNotchPos);

  // Right always steps
  state.right.pos = (state.right.pos + 1) % 26;

  // If right was at notch before stepping, step mid
  if( (state.right.pos === (rightNotchPos+1)%26) && ( (state.right.pos-1+26)%26 === rightNotchPos) ){
    // handled by willStepMid logic
  }

  if(willStepMid){ state.mid.pos = (state.mid.pos + 1) % 26; }
  // If mid stepped and is now at notch (approx), step left
  if( (state.mid.pos === (midNotchPos)%26) ){ state.left.pos = (state.left.pos + 1) % 26; }
}

function encodeChar(ch){
  // 1) step rotors (step before encoding)
  stepRotors(); renderPositions();

  // 2) plugboard in
  const in1 = plugSwap(ch);
  const path = [];
  path.push({stage:'plug-in',val:in1});

  // 3) pass forward through right, mid, left
  let v = idx(in1);
  v = rotorForward(v, state.right); path.push({stage:'R→',val:chr(v)});
  v = rotorForward(v, state.mid);  path.push({stage:'M→',val:chr(v)});
  v = rotorForward(v, state.left); path.push({stage:'L→',val:chr(v)});

  // 4) reflector
  v = reflect(v); path.push({stage:'Reflect',val:chr(v)});

  // 5) backward through left, mid, right
  v = rotorBackward(v, state.left); path.push({stage:'L←',val:chr(v)});
  v = rotorBackward(v, state.mid);  path.push({stage:'M←',val:chr(v)});
  v = rotorBackward(v, state.right); path.push({stage:'R←',val:chr(v)});

  // 6) plugboard out
  const outLetter = plugSwap(chr(v)); path.push({stage:'plug-out',val:outLetter});

  return {out: outLetter, path};
}

function highlightPath(path){
  pathDiv.innerHTML='';
  for(let s of path){const span=document.createElement('div'); span.className='step'; span.innerHTML = `<span class="chip">${s.stage}</span> <strong style="margin-left:8px">${s.val}</strong>`; pathDiv.appendChild(span);} 
}

function pressKey(letter){
  // visual: deactivate all lamps
  for(let c of ALPH){document.getElementById('lamp_'+c).classList.remove('on');}
  // encode
  const res = encodeChar(letter);
  // light lamp
  const lamp = document.getElementById('lamp_'+res.out);
  if(lamp) lamp.classList.add('on');
  highlightPath(res.path);
  outputWire.innerHTML = `<div class="chip highlight">${letter} → ${res.out}</div>`;
}

// UI hooks
leftSelect.onchange = ()=>{ state.left.type = leftSelect.value; renderNotches(); }
midSelect.onchange  = ()=>{ state.mid.type  = midSelect.value; renderNotches(); }
rightSelect.onchange = ()=>{ state.right.type = rightSelect.value; renderNotches(); }
reflectorSelect.onchange = ()=>{ state.reflector = reflectorSelect.value; }

// plugboard add/remove
const addPair = document.getElementById('addPair'); document.getElementById('btnAdd').onclick = ()=>{
  const txt = addPair.value.trim().toUpperCase(); if(!txt.match(/^[A-Z]\s+[A-Z]$/)) return alert('Formato: A G');
  const [a,b] = txt.split(/\s+/);
  if(a===b) return alert('No se puede emparejar la misma letra');
  // remove existing mappings
  if(state.plugboard[a] || state.plugboard[b]) return alert('Una de las letras ya está en uso');
  state.plugboard[a]=b; state.plugboard[b]=a; addPair.value=''; renderPlugs();
}

document.getElementById('btnClear').onclick = ()=>{ state.plugboard = {}; renderPlugs(); }

// reset
document.getElementById('btnReset').onclick = ()=>{ state.left.pos=0; state.mid.pos=0; state.right.pos=0; renderPositions(); }
document.getElementById('randomize').onclick = ()=>{ state.left.pos=Math.floor(Math.random()*26); state.mid.pos=Math.floor(Math.random()*26); state.right.pos=Math.floor(Math.random()*26); renderPositions(); }

// Keyboard capture
window.addEventListener('keydown', (e)=>{
  const k = e.key.toUpperCase(); if(ALPH.includes(k)){ pressKey(k); }
});

// Initialize
renderKeyboard(); renderLamps(); renderPositions(); renderPlugs(); renderNotches();

</script>
</body>
</html>
